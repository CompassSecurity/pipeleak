package exploit

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateWorkflowYml(t *testing.T) {
	tests := []struct {
		name                   string
		runnerLabels           []string
		shell                  bool
		ageEncryptionPublicKey string
		expectedContains       []string
		expectedNotContains    []string
	}{
		{
			name:                   "generates basic exploit workflow with no labels",
			runnerLabels:           []string{},
			shell:                  false,
			ageEncryptionPublicKey: "",
			expectedContains: []string{
				"name: Pipeleak Runner Exploit",
				"on:",
				"push:",
				"branches:",
				"- main",
				"jobs:",
				"pipeleak-job-ubuntu-latest:",
				"runs-on:",
				"- ubuntu-latest",
			},
			expectedNotContains: []string{
				"sshx.io",
				"FiloSottile/age",
			},
		},
		{
			name:                   "generates workflow with single runner label",
			runnerLabels:           []string{"self-hosted"},
			shell:                  false,
			ageEncryptionPublicKey: "",
			expectedContains: []string{
				"pipeleak-job-self-hosted:",
				"runs-on:",
				"- self-hosted",
			},
			expectedNotContains: []string{
				"sshx.io",
				"FiloSottile/age",
			},
		},
		{
			name:                   "generates workflow with multiple runner labels",
			runnerLabels:           []string{"ubuntu-latest", "self-hosted", "docker"},
			shell:                  false,
			ageEncryptionPublicKey: "",
			expectedContains: []string{
				"pipeleak-job-ubuntu-latest:",
				"pipeleak-job-self-hosted:",
				"pipeleak-job-docker:",
				"- ubuntu-latest",
				"- self-hosted",
				"- docker",
			},
			expectedNotContains: []string{
				"sshx.io",
				"FiloSottile/age",
			},
		},
		{
			name:                   "includes shell command when shell is true",
			runnerLabels:           []string{},
			shell:                  true,
			ageEncryptionPublicKey: "",
			expectedContains: []string{
				"pipeleak-job-ubuntu-latest:",
				"sshx.io",
				"Start SSHX shell",
			},
			expectedNotContains: []string{
				"FiloSottile/age",
			},
		},
		{
			name:                   "includes age encryption when public key provided",
			runnerLabels:           []string{},
			shell:                  false,
			ageEncryptionPublicKey: "age1abc123xyz456",
			expectedContains: []string{
				"pipeleak-job-ubuntu-latest:",
				"age",
				"Encrypt environment variables",
				"age1abc123xyz456",
			},
			expectedNotContains: []string{
				"sshx.io",
			},
		},
		{
			name:                   "includes both shell and age encryption",
			runnerLabels:           []string{"self-hosted"},
			shell:                  true,
			ageEncryptionPublicKey: "age1testkey",
			expectedContains: []string{
				"pipeleak-job-self-hosted:",
				"sshx.io",
				"age",
				"age1testkey",
			},
			expectedNotContains: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := GenerateWorkflowYml(tt.runnerLabels, tt.shell, tt.ageEncryptionPublicKey)

			assert.NotEmpty(t, result)

			for _, expected := range tt.expectedContains {
				assert.Contains(t, result, expected, "YAML should contain: %s", expected)
			}

			for _, notExpected := range tt.expectedNotContains {
				assert.NotContains(t, result, notExpected, "YAML should not contain: %s", notExpected)
			}

			assert.Contains(t, result, "name: Pipeleak Runner Exploit")
			assert.Contains(t, result, "on:")
			assert.Contains(t, result, "jobs:")
		})
	}
}

func TestGenerateWorkflowYml_YAMLStructure(t *testing.T) {
	t.Run("generates valid YAML structure", func(t *testing.T) {
		result := GenerateWorkflowYml([]string{}, false, "")

		lines := strings.Split(result, "\n")
		require.Greater(t, len(lines), 5, "YAML should have multiple lines")

		hasJob := false
		for _, line := range lines {
			if strings.Contains(line, "pipeleak-job") {
				hasJob = true
				break
			}
		}
		assert.True(t, hasJob, "YAML should define at least one pipeleak job")
	})
}

func TestGenerateWorkflowYml_EdgeCases(t *testing.T) {
	t.Run("handles nil runner labels", func(t *testing.T) {
		result := GenerateWorkflowYml(nil, false, "")
		assert.NotEmpty(t, result)
		assert.Contains(t, result, "pipeleak-job-ubuntu-latest:")
	})

	t.Run("handles empty string age key", func(t *testing.T) {
		result := GenerateWorkflowYml([]string{}, false, "")
		assert.NotContains(t, result, "FiloSottile/age")
	})

	t.Run("handles special characters in labels", func(t *testing.T) {
		result := GenerateWorkflowYml([]string{"ubuntu-20.04", "linux_amd64"}, false, "")
		assert.Contains(t, result, "ubuntu-20.04")
		assert.Contains(t, result, "linux_amd64")
	})
}

func TestCreateExploitJob(t *testing.T) {
	t.Run("creates job with basic structure", func(t *testing.T) {
		job := CreateExploitJob([]string{"ubuntu-latest"}, false, "")

		assert.Equal(t, []string{"ubuntu-latest"}, job.RunsOn)
		assert.Greater(t, len(job.Steps), 0)

		hasSetupStep := false
		hasExploitStep := false
		for _, step := range job.Steps {
			if step.Name == "Setup environment" {
				hasSetupStep = true
			}
			if step.Name == "Run exploit" {
				hasExploitStep = true
			}
		}

		assert.True(t, hasSetupStep, "Job should have setup step")
		assert.True(t, hasExploitStep, "Job should have exploit step")
	})

	t.Run("includes shell step when shell is true", func(t *testing.T) {
		job := CreateExploitJob([]string{"ubuntu-latest"}, true, "")

		hasShellStep := false
		for _, step := range job.Steps {
			if step.Name == "Start SSHX shell" {
				hasShellStep = true
			}
		}

		assert.True(t, hasShellStep, "Job should have shell step")
	})

	t.Run("includes age encryption step when key provided", func(t *testing.T) {
		job := CreateExploitJob([]string{"ubuntu-latest"}, false, "age1testkey")

		hasAgeStep := false
		for _, step := range job.Steps {
			if step.Name == "Encrypt environment variables" {
				hasAgeStep = true
				assert.Contains(t, step.Run, "age1testkey")
			}
		}

		assert.True(t, hasAgeStep, "Job should have age encryption step")
	})
}

func TestJoinCommands(t *testing.T) {
	t.Run("joins multiple commands with newlines", func(t *testing.T) {
		commands := []string{"echo hello", "echo world", "ls -la"}
		result := JoinCommands(commands)

		assert.Equal(t, "echo hello\necho world\nls -la", result)
	})

	t.Run("handles single command", func(t *testing.T) {
		commands := []string{"echo hello"}
		result := JoinCommands(commands)

		assert.Equal(t, "echo hello", result)
	})

	t.Run("handles empty slice", func(t *testing.T) {
		commands := []string{}
		result := JoinCommands(commands)

		assert.Equal(t, "", result)
	})
}
